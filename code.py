# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1upSOoPSUw4CingdNk3xz9DHeHF8nFuKr
"""

import zipfile
import os
import cv2
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.callbacks import ModelCheckpoint

# Constants
IMG_SIZE = 64

def extract_zip(zip_path, extract_to="dataset"):
    """Extracts a ZIP file to a specified folder."""
    if not os.path.exists(extract_to):
        os.makedirs(extract_to)
    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        zip_ref.extractall(extract_to)
    print(f"âœ… Dataset extracted to '{extract_to}'")

def resize_image(image, size=IMG_SIZE):
    return cv2.resize(image, (size, size))

def show_resized_image(image_path):
    image = cv2.imread(image_path)
    if image is None:
        print("Error: Could not read image!")
        return
    resized_image = resize_image(image)

    fig, axes = plt.subplots(1, 2, figsize=(8, 4))
    axes[0].imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    axes[0].set_title("Original Image")
    axes[0].axis("off")

    axes[1].imshow(cv2.cvtColor(resized_image, cv2.COLOR_BGR2RGB))
    axes[1].set_title("Resized Image")
    axes[1].axis("off")

    plt.show()

def load_dataset_with_csv(zip_path, csv_path):
    df = pd.read_csv(csv_path)
    df['Label'] = df['Label'].str.strip().str.lower()
    label_map = {'fake': 0, 'genuine': 1}
    X, y = [], []

    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        zip_files = {name.replace('/', os.sep): name for name in zip_ref.namelist()}

        for _, row in df.iterrows():
            csv_filename = row['Filename'].replace('\\', os.sep).strip()
            label_str = row['Label']
            if label_str not in label_map or csv_filename not in zip_files:
                continue
            with zip_ref.open(zip_files[csv_filename]) as file:
                img_array = np.frombuffer(file.read(), np.uint8)
                image = cv2.imdecode(img_array, cv2.IMREAD_COLOR)
                if image is not None:
                    image = resize_image(image) / 255.0
                    X.append(image)
                    y.append(label_map[label_str])
    return np.array(X), to_categorical(y, num_classes=2)

def build_cnn_model(input_shape):
    model = Sequential([
        Conv2D(32, (3, 3), activation='relu', input_shape=input_shape),
        MaxPooling2D(2, 2),
        Conv2D(64, (3, 3), activation='relu'),
        MaxPooling2D(2, 2),
        Conv2D(128, (3, 3), activation='relu'),
        MaxPooling2D(2, 2),
        Flatten(),
        Dense(128, activation='relu'),
        Dropout(0.5),
        Dense(2, activation='softmax')
    ])
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    return model

def train_cnn_model(X, y, save_path="logo_cnn_model.h5"):
    labels = y.argmax(axis=1)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, stratify=labels, random_state=42)

    datagen = ImageDataGenerator(
        rotation_range=50,
        zoom_range=0.1,
        width_shift_range=0.1,
        height_shift_range=0.1,
        horizontal_flip=True
    )
    datagen.fit(X_train)

    model = build_cnn_model(X.shape[1:])
    checkpoint = ModelCheckpoint(save_path, save_best_only=True, monitor='val_accuracy', mode='max', verbose=0)

    model.fit(datagen.flow(X_train, y_train, batch_size=32),
              validation_data=(X_test, y_test),
              epochs=10,
              callbacks=[checkpoint])

    loss, acc = model.evaluate(X_test, y_test)
    print(f"\nAccuracy: {acc:.2f}")

    y_pred = model.predict(X_test)
    y_pred_labels = np.argmax(y_pred, axis=1)
    y_true_labels = np.argmax(y_test, axis=1)

    print("\nClassification Report:")
    print(classification_report(y_true_labels, y_pred_labels, target_names=["Fake", "Real"]))

    cm = confusion_matrix(y_true_labels, y_pred_labels)
    plt.figure(figsize=(6, 5))
    sns.heatmap(cm, annot=True, fmt="d", cmap="Blues", xticklabels=["Fake", "Real"], yticklabels=["Fake", "Real"])
    plt.title("Confusion Matrix")
    plt.xlabel("Predicted")
    plt.ylabel("Actual")
    plt.show()

def predict_image_with_cnn(image_path, model_path="logo_cnn_model.h5"):
    model = load_model(model_path)
    image = cv2.imread(image_path)
    if image is None:
        print("Image not found!")
        return
    show_resized_image(image_path)  # Display before and after resizing
    resized = resize_image(image) / 255.0
    input_img = np.expand_dims(resized, axis=0)
    prediction = model.predict(input_img)[0]
    label = np.argmax(prediction)
    print(f"Fake: {prediction[0]:.2f}, Real: {prediction[1]:.2f}")
    print(f"Predicted: {'Real' if label == 1 else 'Fake'} Logo")

if __name__ == "__main__":
    zip_path = "/content/fakelogoo.zip"
    csv_path = "/content/fakelogo/file_mapping.csv"
    test_image_path = "/content/faki.png"

    extract_zip(zip_path, "/content/fakelogo")
    X, y = load_dataset_with_csv(zip_path, csv_path)
    train_cnn_model(X, y)
    predict_image_with_cnn(test_image_path)